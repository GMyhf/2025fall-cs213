# ICS 小班研讨题和作业题

*Updated 2025-09-17 14:47 GMT+8*  
 *Compiled by GM (2025 Fall)*    

https://github.com/GMyhf/2025fall-cs213/



> 关于小班研讨题的说明
>
> 本学期对以往的“小班回课”环节进行了优化， 采用了“小班研讨题”的形式作为替代。 这并非完全颠覆原有方式， 而是希望通过内容更聚焦、 参与研讨人数更多的方式， 帮助学生掌握课程内容的重点。
>
> 以往的回课形式， 在小班有限的时间内（ 如每人 20 至 30 分钟） ， 学生往往较难正确的梳理回顾两个小时的大课内容， 会出现流水账形式、 重点不突出， 或者以偏概全、 遗漏了重点。 因此， 这次将大课中应重点学习掌握的核心内容提炼成研讨题， 方便在小班课上集中讨论。
>
> 需要注意， 研讨题不是作业题， 而更像是用问题的形式列出了重点内容的提纲。 研讨题是紧密结合课件和教材内容， 如无特别说明是拓展研讨， 是不需要用到超出课堂的扩展知识。学生基于研讨题的脉络， 通过分析与讲解， 达到巩固知识、 深化理解、 提升思考的目的。“ 拓展研讨” 是否在小班上做， 根据时间安排， 由小班老师决定。
> 除了研讨题， 每次大课还会布置几道作业题。 由于都是基于本讲课程， 部分作业题的内容， 会和研讨题有关联。 这些作业题， 可以在课后时间完成， 由助教批改， 并在小班上讲解；也可以安排在小班上由学生上台分析、 大家研讨。 具体形式由小班教师决定。



> 覆盖并回答了绝大多数问题（位/字节、整型编码、位运算、xbyte 实现、浮点格式与运算要点），并给出了可直接用的代码实现与若干具体数值（如 2.59 的表达式、2.60 实现、2.71 的正确实现、half-precision 的 `512` 与 `0x3BB0` 的布置与值）



# 第 2 讲 Bits, Bytes, and Integers

> 注： 研讨题的默认前提基础是本课程尤其是本讲的课件和对应教材内容， 不一定每次都做强调说明， 例如基于 x86 体系结构、 Linux 操作系统、 C 语言程序等。

## 研讨题 1： 关于“ 位” （ bit） 和字节（ byte）

（ 1） 计算机内部选用了二进制表达形式， 那为什么要用十六进制？ 在什么场合使用？ 和十
进制相比有什么优缺点？

要点：

- **计算机内部用二进制**（bit）表示信息；但二进制太长，不便人类阅读/书写。十六进制（hex）把每 4 个二进制位映射到一个十六进制字符（0–F），对齐良好、长度短，因此常用于显示内存/寄存器/机器码等低层信息。

- **使用场合**：内存地址、机器码/指令编码、调试输出、颜色代码（网页）、表示字节流、低层协议、位掩码常量等。

- **优点**：与二进制直接对应（易于转换），更紧凑；便于按字节/半字节观察和定位位字段。

- **缺点**：不如十进制直观地表示“人类计数”；在解释数值大小（例如货币）时，人类偏好十进制。

  

（ 2） 参照课件第 4 页， 设计几个 8 位的二进制数（ 不能用课件上现成的） ， 手工转换成十
进制和十六进制， 按步骤展示过程， 体现转换的速度差异。 注意要多用到十六进制中字母的
表示， 熟悉十六进制的特点。

P4

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917140248199.png" alt="image-20250917140248199" style="zoom:50%;" />



示例 3 个 8 位数（要求不能用课件上现成的）：

1. `1010 1110₂`
   - 二进制到十进制：`1*2^7 +0*2^6 +1*2^5 +0*2^4 +1*2^3 +1*2^2 +1*2^1 +0*2^0 = 128 + 32 + 8 +4 +2 =174` → `174_{10}`。
   - 转十六进制：每 4 位一组：`1010`=`A`, `1110`=`E` → `0xAE`。
     说明：手工分组 4 位转 hex 比逐位写十进制更快。
2. `0101 0011₂` → `0x53` → 十进制 `83`。
3. `1111 0001₂` → `0xF1` → 十进制 `241`。

（演示了二进制→hex 的速度与便利：每 4 位直接映射到 1 个 hex 字符）



（ 3） **拓展研讨**： 现在主流的设计方案是 8 位为 1 个字节， 4 个字节为 1 个字（ int 整型数） 。
你觉得这样设计是什么原因？ 有什么优点和不足？ 还有其他更好或者也很好的方式吗？

- **历史+工程权衡**：8 位一字节起源于字符编码（早期有 6/7/8 位编码），8 位能容纳 ASCII 扩展（或一个字节存储一个字符）且与 2 的幂对齐（便于硬件）。
- **优点**：与字长（32/64 位）整除便于对齐、寻址和内存操作；硬件实现简单；字节为最小可寻址单位（方便 I/O、字节流处理）。
- **缺点**：某些特定应用可能需要更小（嵌入式节省存储）或更大字节（字节对齐浪费）。另一个问题是字节端序（big/little endian）。
- **其他方案**：字节宽度并非绝对。历史上有 9-bit、36-bit 机、6-bit 字符机等；理论上也可采用 16-bit 字节等，但与现有生态（字节流协议、文件格式、库函数）兼容性差。



（ 4） 参照课件第 8 页， 设计两个单字节的二进制数（ 不能用课件上现成的） ， 展示位级的
与、 或、 非、 异或运算。

P8

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917140448617.png" alt="image-20250917140448617" style="zoom:50%;" />

取 `a = 0x5A = 01011010₂`，`b = 0xC3 = 11000011₂`：

- `a & b = 01011010 & 11000011 = 01000010 = 0x42`
- `a | b = 01011010 | 11000011 = 11011011 = 0xDB`
- `~a = 10100101 = 0xA5` （在单字节语义下取反；在 C 的 int 表示上 `~a` 会扩展到机器字长）
- `a ^ b = 10011001 = 0x99`

（演示：按位逐位计算即可）



（ 5） 参照课件第 11 页， 设计几个单字节的数（ 十六进制表达形式， 不能用课件上现成的），
展示 C 语言中逻辑操作的与、 或、 非。 比较分析这些操作和位级操作的异同。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917140540674.png" alt="image-20250917140540674" style="zoom:50%;" />



举例（按题要求用 hex 表示）：

令 `x = 0x01`（非零），`y = 0x00`（零）：

- 位操作：`x & 0xFF` 是位级与，会把对应位清0或保留。位运算操作按位独立处理，结果仍为位掩码值（0..255 等）。
- 逻辑操作：`x && y` 首先将 `x` 与 `y` 转换为布尔（0或1），返回 0 或 1（类型 `int`）。例如 `0x01 && 0x02` 为 `1`（尽管按位或为 `0x03`）。

**主要差异**：

- 位运算保留位信息，逻辑运算把操作数视为布尔并返回 0/1。
- 在 C 中 `!p` 的结果是 `0` 或 `1`，`~p` 是逐位取反且依赖于整型宽度。



（ 6） 课件第 11 页提到了“ p&&*p” 可以避免空指针访问， 找出现实中关于这种操作的实际
代码片段， 并说明其原理。

示例（C）：

```c
char *p = /* 可能为 NULL */;
if (p && *p) {
    /* 只有当 p 非 NULL 且 *p 非零字符时进入 */
}
```

原理：`&&` 的左操作数先求值，如果为 0（false）则短路不求右操作数。`p && *p` 利用短路性质避免对空指针 `p`做 `*p`（解引用）从而避免空指针访问崩溃。常见写法有 `if (p && *p)`、`if (p != NULL && *p != '\0')`。

真实代码片段：`if (str && *str) printf("%s\n", str);` （检查字符串非 NULL 且非空串再打印）



（ 7） 参照课件第 12 页， 设计几个单字节的二进制数（ 不能用课件上现成的） ， 展示左移和两种右移操作。 结合本讲后面学到的知识， 分析为什么需要两种右移。

P12

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917140618308.png" alt="image-20250917140618308" style="zoom:50%;" />



取 `b = 0b1001_0110`（假设单字节）：

- `b << 2` = 左移：`0010_1100`（高位舍弃，低位补 0）。相当于乘以 2^2（无符号语义下）。
- 逻辑右移（~unsigned）：`b >> 2 (logical)` = `0010_0101`（高位补 0）。
- 算术右移（~signed）：`b >> 2 (arithmetic)` 若最高位为 1（负数），高位补 1，以保持符号位（符号扩展）。例如在有符号表示 `10010110`（负数），算术右移结果高位用 1 填充以维持符号。

**为什么要两种**：

- 对 **无符号数** 或位域处理需要逻辑右移（用 0 补）以实现纯二进制位的除法/位移动。
- 对 **有符号数**（补码）进行算术右移能保持符号（相当于除以 2 且向下取整），有利于算术操作与符号保持一致。



## 研讨题 2： 关于整型数

（ 1） 参照课件第 14 页， 设计几个 short int 类型的数（ 不能用课件上现成的） ， 用 B2U 和
B2T 两个公式分别进行十进制到二进制的手工转换， 按步骤展示过程。 要包含正数、 负数
和最大最小等边界情况。

假设 `short` 为 16 位（w=16），举例：

- `x_bits = 0x1234`（十进制 4660）
  - B2U(x) = 0x1234 = 4660。
  - B2T(x): MSB=0 → 同 B2U，结果 4660（有符号也为正）。
- `x_bits = 0xF234`（二进制 MSB=1）
  - B2U = 0xF234 = 62004（无符号）
  - B2T = interpret as two's complement: 若位模式 `0xF234`，则值 = `0xF234 - 2^16 = 62004 - 65536 = -35232`。
- 边界：
  - 最大正数（signed short） = `0x7FFF` = +32767。
  - 最小负数 = `0x8000` = -32768（two's complement）。

**公式**：

- B2U(bits) = sum_{i=0}^{w-1} bit_i * 2^i
- B2T(bits) = if MSB == 0 then B2U(bits) else B2U(bits) - 2^w





（ 2） 教材上提到了有符号数的其他编码方法（ 原码、 反码） ， 介绍其编码规则， 并和补码
比较优缺点。

- **原码（sign-magnitude）**：最高位为符号（0正、1负），其余位为绝对值二进制表示。
  - 优点：直观（符号+幅度），正负对称表示。
  - 缺点：两种零 (+0 / -0)、加法器复杂（需处理符号位和进位规则），硬件实现复杂。
- **反码（ones' complement）**：正数同原码；负数为正数的按位取反（ones' complement）。
  - 优点：比原码在某些加法上更简洁。
  - 缺点：依然有 +0 / -0；加法需要末位进位加回（end-around carry）。
- **补码（two's complement）**：负数表示为正数按位取反加 1，即 `-x = ~x + 1`。
  - 优点：只有一个零，硬件加法器无需区分正负，算术运算统一（简化电路）。
  - 缺点：表示范围不对称：负数比正数多一个（例如 32-bit，最负为 -2^31，最大正为 2^31-1）。

因此现代计算机使用**补码**。



（ 3） 拓展研讨： 课件第 19 页提到的补码数取反操作， 证明其成立。

P19

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917141928775.png" alt="image-20250917141928775" style="zoom:50%;" />



证明：补码负数表示 `-x = 2^w - x`（对 `w` 位）。按位取反 `~x = 2^w - 1 - x`，因此 `~x + 1 = (2^w - 1 - x) + 1 = 2^w - x`，即补码的求负等价于 `~x + 1`。证毕。



（ 4） 参照课件第 14 页， 设计几个有符号数和无符号数（ 不能用课件上现成的） ， 分析它
们进行比较时成立的关系。

P14

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917142106903.png" alt="image-20250917142106903" style="zoom:50%;" />

举例：二进制位 `0xFFFFFFFF`（32 位全 1）：

- 作为 **unsigned**：`0xFFFFFFFF = 4294967295`
- 作为 **signed**（two's complement）：`0xFFFFFFFF = -1`

比较 `x < y` 在 signed 与 unsigned 下会有差异。例如：

- `0xFFFFFFFE` < `0xFFFFFFFF` 作为 unsigned：`4294967294 < 4294967295` → true
- 作为 signed：`0xFFFFFFFE = -2`，`0xFFFFFFFF = -1` → -2 < -1 → true （有时同结果，但不同语义导致许多潜在错误）

另一个典型：`0x80000000`（最高位 1）作为 unsigned 是 `2147483648`，作为 signed 是 `-2147483648`。因此 `unsigned(0x80000000) > signed(0x7FFFFFFF)`，但按 signed 解释则相反。



（ 5） 简述扩展和截断的原则， 重点分析为什么要用符号扩展方式（ 相比于直接在高位补 0），
有什么用途。 可以结合后面的乘法和除法等运算来思考。



- **截断（narrowing）**：丢弃高位（取低位）。
- **扩展（widening）**：
  - **无符号扩展**：高位补 0（zero-extend）。
  - **有符号扩展**：高位用符号位填充（sign-extend）。
- **为什么用符号扩展**：保持数值不变。在二's补码下，把有符号数从小位宽扩到大位宽时，要保留数值的算术含义，必须复制符号位到高位。例如 8-bit `0xFF`（-1）扩到 32-bit 应为 `0xFFFFFFFF`（仍然 -1），若零扩展会变成 `0x000000FF`（255），会改变数值语义。
- **用途**：在算术运算（加减、乘除）以及与其他宽度操作交互时保持语义一致。



（ 6） 设计几个数， 分别在无符号数加法中产生溢出、 在有符号数加法中产生两种溢出。

- **无符号溢出**（32-bit）：`0xFFFFFFFFu + 1u = 0x00000000`（模 2^32 回绕）。示例：`UINT_MAX + 1 => 0`。
- **有符号溢出**（32-bit）两种情况：
  - **正向溢出（正＋正→负）**：`0x7FFFFFFF + 1 = 0x80000000`（从 +2147483647 溢出到 -2147483648）
  - **负向溢出（负＋负→正）**：`0x80000000 + 0xFFFFFFFF`（例如 `-2147483648 + -1 = 2147483647`，位模式回绕）
    注：C 标准中有符号溢出是未定义行为，但硬件上通常是模 2^w 回绕。



（ 7） 基于课件第 48 页， 分析为什么会用移位来代替部分乘法操作， 分析哪些乘法操作不
会被移位代替。

P48

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917142306036.png" alt="image-20250917142306036" style="zoom:50%;" />



- **用移位可代替乘以 2^k**（高效）。例如 `x << k` 等价于 `x * (2^k)`（当无溢出 / 对无符号数或在期望的语义下）。
- **不能完全代替的情形**：
  - 乘以非 2 的幂的常数（例如乘 3 需要 `x<<1 + x`）——可能用移位加法组合实现，但复杂性更高。
  - 有符号乘法的符号/溢出语义需要注意：直接移位可能改变符号位（算术与逻辑差异）。
  - 小数或非整数乘法（浮点）不能用位移替代。
- **总结**：移位用于幂-of-two 系列乘法非常高效；其他因子须通过移位 + 加法等组合（编译器常做优化）。



（ 8） 参照课件第 61 页， 设计几个 4 字节的数（ 不能用课件上现成的） ， 分别用大端模式
和小端模式放在某个指定的内存位置。

P61

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917142343927.png" alt="image-20250917142343927" style="zoom:50%;" />



给定 4 字节数 `0x12345678`，存放在内存地址 `0x1000` 处（按字节地址递增）：

- **大端（big-endian）**（高字节放低地址）：
  - 地址 `0x1000` : `0x12`
  - `0x1001` : `0x34`
  - `0x1002` : `0x56`
  - `0x1003` : `0x78`
- **小端（little-endian）**（低字节放低地址）：
  - 地址 `0x1000` : `0x78`
  - `0x1001` : `0x56`
  - `0x1002` : `0x34`
  - `0x1003` : `0x12`



（ 9） 拓展研讨： 如果一台基于 x86（ 采用小端格式） 的计算机从互联网上获取了一些数据
（ 采用大端格式） ， 那会不会对这些数据进行格式转换？ 如果转换， 在什么地方、 在什么时
候转换？

网络字节序（big-endian）与 x86 主机字节序（little-endian）不同。通常在**协议解析/序列化（socket read/write）层或库层**做转换，使用 POSIX/Winsock 提供的 `ntohl()`、`htonl()`、`ntohs()`、`htons()` 等函数或在应用层手工处理。转换发生在**读取网络字节流并将其解释为主机数值时**，或把主机整数发送到网络之前。网络库或协议栈通常在边界做转换。





## 作业题

第 2 讲 bit byte int 的作业题， 在教材第 2 章 信息的表示和处理， 页码和题号如下：


### 2.59 

P88 2.59 编写一个C表达式，它生成一个字，由 x 的最低有效字节和 y 中剩下的字节组成。对于运算数`x=0x89ABCDEF`和 `y=0x76543210`，就得到 `0x765432EF`。



**表达式**（C）：

```c
/* 取 x 的最低字节，y 的其余字节 */
unsigned result = (x & 0xFFu) | (y & ~0xFFu);
```

验证：`(0x89ABCDEF & 0xFF) = 0xEF`；`(0x76543210 & ~0xFF) = 0x76543200` → 或后 `0x765432EF`。



### 2.60 

P88 2.60 假设我们将一个 `w` 位的字中的字节从 0（最低位）到 `w/8-1`（最高位）编号。写出下面C函数的代码，它会返回一个无符号值，其中参数 `x` 的字节 `i` 被替换成字节b:

```c
unsigned replace_byte(unsigned x, int i, unsigned char b);
```

以下示例，说明了这个函数该如何工作:

```
replace_byte(0x12345678，2，0xAB)-->0x12AB5678
replace byte(0x12345678，0，0xAB)--> 0x123456AB
```

**位级整数编码规则**

在接下来的作业中，我们特意限制了你能使用的编程结构，来帮你更好地理解C语言的位级、逻辑和算术运算。在回答这些问题时，你的代码必须遵守以下规则:

假设

- 整数用补码形式表示
- 有符号数的右移是算术右移。
- 数据类型 int是w位长的。对于某些题目，会给定w的值，但是在其他情况下，只要w是8的整数倍，你的代码就应该能工作。你可以用表达式 sizeof(int)<<3 来计算w。

禁止使用

- 条件语句（if或者?:）、循环、分支语句、函数调用和宏调用。
- 除法、模运算和乘法。
- 相对比较运算(<、>、<=和>=)。

允许的运算

- 所有的位级和逻辑运算。
- 左移和右移，但是位移量只能在0和w-1之间。
- 加法和减法。
- 相等(==)和不相等(!=)测试。(在有些题目中，也不允许这些运算。)
- 整型常数INT MIN和INT MAX。
- 对 int和 unsigned进行强制类型转换，无论是显式的还是隐式的。

即使有这些条件的限制，你仍然可以选择带有描述性的变量名，并且使用注释来描述你的解决方案的逻辑，尽量提高代码的可读性。例如，下面这段代码从整数参数x中抽取出最高有效字节:

```c
/* Get most significant byte from x*/
int get_msb(int x){
	/* Shift by w-8 */
	int shift val=(sizeof(int)-1)<<3;
	/* Arithmetic shift */
	int xright=x>> shift_val;
	/*Zero all but LSB */
	return xright &OxFF:
}
```



Answer:

**实现（清晰、遵守限制）**：

```c
unsigned replace_byte(unsigned x, int i, unsigned char b) {
    int shift = i << 3;               /* shift = i * 8 */
    unsigned mask = 0xFFu << shift;   /* mask selecting byte i */
    return (x & ~mask) | ((unsigned)b << shift);
}
```

说明：`~mask` 把目标字节清 0，`(unsigned)b << shift` 把新字节移到位置，再或回去。





### 2.71

你刚刚开始在一家公司工作，他们要实现一组过程来操作一个数据结构，要将4个有符号字节封装成一个 32位 unsigned。一个字中的字节从0(最低有效字节)编号到3(最高有效字节)。分配给你的任务是:为一个使用补码运算和算术右移的机器编写一个具有如下原型的函数:

```c
/*Declaration of data type where 4 bytes are packedinto an unsigned */
typedef unsigned packed t;

/* Extract byte from word.Return as signed integer */
int xbyte(packed t word,int bytenum);
```

也就是说，函数会抽取出指定的字节，再把它符号扩展为一个32位int。你的前任（因为水平不够高而被解雇了）编写了下面的代码:

```c
/*Failed attempt at xbyte */
int xbyte(packed_t word,int bytenum)
{
  return (word >> (bytenum << 3 )) & 0xFF;
}
```

A.这段代码错在哪里?

B.给出函数的正确实现，只能使用左右移位和一个减法。



Answer:

题目：从 `packed_t word`（4 字节）中提取指定字节并作为 **有符号 int** 返回（符号扩展）。

**A. 错在哪里？**

原实现：

```c
int xbyte(packed_t word,int bytenum)
{
  return (word >> (bytenum << 3 )) & 0xFF;
}
```

**错误原因**：`(word >> ...) & 0xFF` 会得到目标字节的无符号值（0..255），但没有对该字节进行**符号扩展**。当被提取字节最高位为 1（即原字节表示负数）时，需要把其作为负数返回（在 32 位 `int` 中符号扩展），原实现却只返回 0x??（正值）。

**B. 正确实现（只用左右移和一个减法）**

一个常见且符合题目限制的实现（假定 32-bit）：

```c
/* Correct xbyte implementation */
int xbyte(packed_t word, int bytenum) {
    int shift = (3 - bytenum) << 3; /* shift left to bring target byte to MSB */
    /* 左移把目标字节移到最高字节位置，然后算术右移回 24 位来完成符号扩展 */
    return ((int)word << shift) >> 24;
}
```

说明：这里只用左移和右移（一次左移一次算术右移），并用 `(3 - bytenum)` 的减法来计算移位量（满足“只使用左右移和一个减法”的要求）。把字节移到最高字节后，算术右移 `>> 24` 会把最高字节按符号位扩展到整个 `int`。



### 附：关键 C 代码片段（可运行）

`2.59` 和 `2.60` 与 `xbyte` 的完整实现：

```c
/* 2.59 */
unsigned combine_low_byte(unsigned x, unsigned y) {
    return (x & 0xFFu) | (y & ~0xFFu);
}

/* 2.60 */
unsigned replace_byte(unsigned x, int i, unsigned char b) {
    int shift = i << 3;               /* shift = i * 8 */
    unsigned mask = 0xFFu << shift;   /* mask selecting byte i */
    return (x & ~mask) | ((unsigned)b << shift);
}

/* 2.71 xbyte (correct) */
typedef unsigned packed_t;
int xbyte(packed_t word, int bytenum) {
    int shift = (3 - bytenum) << 3;      /* move target byte to MSB */
    return ((int)word << shift) >> 24;   /* arithmetic right shift does sign-extension */
}
```

注：`xbyte` 假定 `int` 32 位并且右移是算术右移（题目条件）。





# 第3讲 Floating Point

> 注： 研讨题的默认前提基础是本课程尤其是本讲的课件和对应教材内容， 不一定每次都
> 做强调说明， 例如 IEEE 754 标准、 C 语言程序等。



## 研讨题 1： 浮点数的格式

（ 1） 课件最开始介绍的二进制小数表达方式是固定小数点位置的（ 定点数） ， 对比浮点数，
分析定点数的优点和缺点， 举出实例配合分析。

- **定点**（小数点固定位置）：
  - 优点：实现简单、精确（若小数位长度固定可避免舍入误差）、适合需要固定小数位置的场景（如某些嵌入式音频、货币处理在限定范围内）。运算速度快、硬件简单。
  - 缺点：动态范围小，不适合同时表示极大与极小的数。数溢出/下溢风险。
- **浮点**（尾数 + 指数，类似科学计数）：
  - 优点：大动态范围（能表示非常大或非常小的数），适合科学计算。
  - 缺点：舍入误差、非交换性（浮点加法非结合），实现复杂，存在 NaN/Inf 等特殊值处理。
- **示例**：定点适合固定小数位的金融系统（但要小心舍入策略）；浮点用于物理仿真、图形学、数值计算。



（ 2） **拓展研讨**： 基于课件第 9 页， 调研并讲述这两个重大事故， 分析浮点数的重大影响。

> P9: This is important!
> Ariane 5 explodes on maiden voyage: $500 MiLLlON dollars lost
>
> - 64-bit floating point number assigned to 16-bit integer (1996)
> - Legacy code from Ariane 4 with a lower top speed
> - Causes rocket to get incorrect value of horizontal velocity and crash
>
> Patriot Missile defense system misses scud-28 people die
>
> - System tracks time in tenths of second
> - Converted from integer to floating point number.
> - Accumulated rounding error causes drift. 20% drift over 8 hours.
> - Eventually (on 2/25/1991 system was on for 100 hours) causes range misestimation sufficiently large to miss incoming missiles.



要点总结（如课件 P9）：

- **Ariane 5 火箭首飞爆炸（1996）**：由遗留于 Ariane 4 的浮点到整数的转换与溢出导致（将 64-bit 浮点赋给 16-bit 整数，超出范围），产生错误导航数据，导致发射器自毁。
- **Patriot 防空系统失误（1991）**：时间计数用十进制/整数转换为浮点累加导致累积舍入误差，长期运行后导致跟踪偏差，最终拦截失败，造成人员伤亡。

结论：浮点运算和类型转换的不当使用可导致灾难性后果（尤其在实时/嵌入式/控制系统中）。





（ 3） 基于课件第 11 页和教材相关内容， 说明公式中 s、 M、 E 对应的英文名词和中文翻译，
介绍 MSB、 exp、 frac 对应的英文全称和中文翻译。

P11

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917134415093.png" alt="image-20250917134415093" style="zoom: 50%;" />

Answer:

- `s`：sign 位（符号位，0 正，1 负）。
- `M`：mantissa 或 significand（尾数/有效位）；中文常称“尾数”或“有效数”。
- `E`：exponent（阶码/指数）。
- `MSB`：most significant bit（最高有效位）。
- `exp`：exponent field（指数域）。
- `frac`：fraction field（尾数的分数部分，也称小数域）。



（ 4） 根据课件第 14、 15、 18 页， 设计一个对应规格化数的单精度浮点数（ 不能用课件上
现成的例子） ， 边做转换， 边讲述规格化数的规则设定， 分析设计上有哪些巧妙之处和需要
特别注意的地方。

P14

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917134529937.png" alt="image-20250917134529937" style="zoom:50%;" />

P15

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917134605215.png" alt="image-20250917134605215" style="zoom:50%;" />



P18

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917134638197.png" alt="image-20250917134638197" style="zoom:50%;" />

Answer:

单精度 IEEE-754：1 位符号，8 位指数（bias=127），23 位尾数（隐含 1）。

例：表示 `-6.5`：

1. 绝对值 `6.5` 的二进制：`110.1₂ = 1.101 × 2^2`。
2. 规格化形式：`sign = 1`，`M = 1.101`（隐含 1 即存储 `101000...` 到 frac），`E = 2`。
3. 存储指数域：`E_field = E + bias = 2 + 127 = 129 = 10000001₂`。
4. frac（23 位）填 `101000...0`（后补零）。
5. 最终二进制表示拼接为 `1 | 10000001 | 101000000...` → 十六进制可计算得到。

设计注意点：规格化要求尾数的最高位是 1（隐含位），指数域偏移表示法避免负指数的直接存储；这种设计使得规格化数呈现最大的有效精度。



（ 5） 规格化数的 exp 域， 看起来是在用无符号数的编码表达有符号数， 但是和之前学的补
码不同在于， 这里是正数比负数多一个， 补码是负数比正数多一个。 这是为什么？ 有什么好
处呢？

- 指数域用偏移（biased）表示（E_field = E + bias），使得指数域自身按无符号数排序时可以直接比较（无需处理符号位）。
- 对于 k 位指数域，偏置为 `2^(k-1)-1`，因此编码范围是 `0..2^k-1`。保留 `exp=0` 用于非规格化/零，`exp=2^k-1` 用于 Inf/NaN；其余代表实际指数。
- 关于“为什么正数比负数多一个”：实际上指数的编码并不是对称性负多正少的讨论（你看到的是浮点在表示指数时的保留编码策略），而**补码之所以负比正多一个**是因为补码的范围 [-2^{w-1}, 2^{w-1}-1]。浮点指数的偏移表示只是编码设计，留下了特殊位型以支持 denorm/Inf/NaN 的表示。



（ 6） 根据课件第 16、 21 页， 设计一个对应非规格化数的单精度浮点数（ 不能用课件上现
成的例子） ， 边做转换， 边讲述非规格化数的规则设定， 分析设计上有哪些巧妙之处和需要
特别注意的地方。 结合后面的课件， 分析+0 和-0 有什么负面影响和正面作用， 解释
Equispaced 是什么意思） 。

P16

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917134723422.png" alt="image-20250917134723422" style="zoom:50%;" />

P21

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917134809778.png" alt="image-20250917134809778" style="zoom:50%;" />

Answer:

- **非规格化数**：当指数域全0但 frac 非 0 时，表示 denormalized：`V = (-1)^s × (0.fraction) × 2^{emin}`（没有隐含 1），用于表示非常接近 0 的数，保证从最小规格化数到 0 的连续性（填补 gap），避免在非常小的数附近出现巨大的下溢间隙（保持数线在零附近均匀分布，称为 Equispaced）。
- **+0 与 -0**：
  - 负面：存在两个零在比较时需要特殊处理，某些等式略微复杂（例如 `-0 == +0` 为真，但符号位仍然可见，比如 `1.0/(-0)` 产生 `-Inf`）。
  - 正面：保留符号信息在数值接近 0 时对方向敏感（例如在浮点除法、某些函数极限方向上有用），并在数值恢复/某些算法中提供一致性（`1.0/(-0) = -Inf`）。
- **Equispaced**：在 denormal 范围内，数值是等间距的（equal spacing），便于在接近 0 时精度一致。





（ 7） 根据课件第 17 页， 讲述特殊值的规则设定， 分析： 为什么要设计“ 无穷” ， 而不是
沿用整型数的溢出， 有什么好处？ 为什么要设计“ 非数” （ NaN)， 有什么好处？ 结合课件
第 29 页， 说明这些设计给浮点数比较带来的影响。

P17

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917134839158.png" alt="image-20250917134839158" style="zoom:50%;" />

P29

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917134923286.png" alt="image-20250917134923286" style="zoom:50%;" />

Answer:

- **设计 Inf 的原因**：相比整型溢出，浮点将溢出映射为 `±Inf` 更有意义，因为它允许在后续计算中传播“无穷大”并维持一定的数学语义（例如 `x + Inf = Inf`），便于错误传播和异常处理。
- **设计 NaN 的原因**：用于表示未定义或不可表示的结果（0/0、Inf-Inf、sqrt(−1)），并能携带诊断信息（某些实现的 NaN payload）。NaN 的存在让错误传播可控（任何涉及 NaN 的运算返回 NaN），而不是蔓延错值。
- **对比较的影响**：NaN 与任何数都不相等（`NaN != NaN` 为真），这破坏了常规比较的某些期望（例如自反性），因此浮点比较需要小心处理 `isnan()` 等。



（ 8） 拓展研讨： NaN 值的 frac 域不为零， 那留了这么多取值的可能， 用来做什么？

frac 域（payload）可以用于携带诊断信息（实现可选），在某些架构/调试环境下用来识别 NaN 来源或错误代码。不同实现对其利用不尽相同，但标准允许保留这些位。



（ 9） 基于课件第 26 页， 配合前后内容， 讲解这种浮点数格式从正无穷到零的变化过程。

P26

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135009399.png" alt="image-20250917135009399" style="zoom:50%;" />



Answer:

简述：正无穷 → 越来越小的大数（规格化）→ 最小规格化数 → 非规格化数（按等距分布接近 0）→ +0。负数对称在另一侧（-∞ ... -0）。排序按数值大小进行，但编码不是线性的，需要考虑指数/尾数域的组合。



## 研讨题 2： 浮点数的运算

（ 1） 根据课件第 32、 33 页， 重新设计几个十进制数字， 讲解这几种舍入方法， 然后重点
讲解“ 向偶数舍入” 的各种边界情况， 分析“ 向偶数舍入” 有什么优势。

P32

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135400151.png" alt="image-20250917135400151" style="zoom:50%;" />



P33

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135427155.png" alt="image-20250917135427155" style="zoom:50%;" />

Answer:

舍入模式常见有：向零、向 +∞、向 −∞、向最近偶数（round-to-even）。**向偶数舍入（Round to nearest, ties to even）**的优点在于：在长期累计多次舍入时能减少偏差（消除系统性偏倚），在等距舍入（恰好在中点）时把结果向偶数舍入能在统计上更中性。

举例（十进制）：

- 把 `2.345` 保留两位小数（四舍五入到 2 位）：
  - 若使用向偶数，`2.345`（第三位 5，中点）→ 看第二位 `4`（偶/奇？4 为偶），通常舍入为 `2.34`（ties to even）。
  - `2.355` → 第二位 5（奇），向偶数会变为 `2.36`。

（详见 IEEE-754 round-to-nearest-even 定义）



（ 2） 根据课件第 34 页， 重新设计几个二进制数字， 展现“ 向偶数舍入” 的各种情况。

P34

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135502341.png" alt="image-20250917135502341" style="zoom:50%;" />

Answer:

举二进制 `1.1000 1000...` 截到某个位数时，若丢弃部分恰好是中间值（后续第一保留位后面为 `1000...`时），应用 round-to-even 根据当前最低保留位（偶/奇）决定进位。



（ 3） 根据课件第 35 页， 重新设计一个运算场景， 边运算边讲解浮点数乘法的流程。

P35

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135531253.png" alt="image-20250917135531253" style="zoom:50%;" />



Answer:

示例：`1.5 × 2.25`（二进制更清晰：`1.1₂ × 10.01₂`）

流程概要：

1. 分离 `sign`、`exp`、`frac`。
2. `result.sign = s1 ^ s2`。
3. `result.exp = exp1 + exp2 - bias`（尾数相乘后要调整指数）。
4. `result.frac = (1.f1) × (1.f2)` → 可能得到 1.xxxx.. 或 10.xxxx，需要规格化（若最高位为 2 的倍数则右移并 `exp++`）。
5. 四舍五入（round-to-nearest-even）到目标精度。
6. 处理溢出/下溢/Inf/NaN。

（课件 P35 展示了细节。我在此给出流程要点）



（ 4） 根据课件第 36 页， 重新设计一个运算场景， 边运算边讲解浮点数加法的流程。

P36

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135559090.png" alt="image-20250917135559090" style="zoom:50%;" />

Answer:

示例：`1.25 + 0.375`（`1.01₂ + 0.011`）

流程：

1. 对齐指数（把较小的数右移，让 exponent 相同）。
2. 对尾数相加（考虑符号）。
3. 规格化（若产生进位或需要左移），调整指数。
4. 舍入到目标精度。
5. 处理特殊情况（Inf/NaN、下溢等）。





（ 5） 根据课件第 37 页， 讲解浮点加法的特性。 详细举例讲解哪些情况下， 单调性不成立。

P37

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135624205.png" alt="image-20250917135624205" style="zoom:50%;" />



（ 6） 根据课件第 38 页， 讲解浮点乘法的特性。 详细举例讲解哪些情况下， 单调性不成立。

38

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135652746.png" alt="image-20250917135652746" style="zoom:50%;" />

Answer:

<mark>（5）（6）浮点加法/乘法单调性不成立举例</mark>

**非单调性（加法）**实例：
当 `x` 很大而 `y` 很小，`x + y` 可能等于 `x`（舍入丢弃 `y`），因此 `x + y == x` 即使 `y > 0`。这显示出在浮点里 `x1 < x2` 不一定导致 `x1 + z < x2 + z`（违背单调性）。

**举例**：

- `x = 1e30f`（单精度），`y = 1.0f` → `x + y` 在单精度下可能等于 `x`（y 被舍弃）。
  因此 `x < x + 2*y` 未必成立。

（乘法类似：浮点乘法在某些边界会导致数值收敛/失真从而违背代数上的交换/结合性）







（ 7） **拓展研讨**： 什么是阿贝尔群， 主要有哪些属性， 具备这些属性有什么意义？

**阿贝尔群（Abelian group）**定义：集合 `G` 配合一个二元运算 `·`，满足：

1. 闭合
2. 结合律：`(a·b)·c = a·(b·c)`
3. 存在单位元 `e`，使 `e·a = a·e = a`
4. 每个元素存在逆元 `a^{-1}` 使 `a·a^{-1} = e`
5. **交换律**（阿贝尔）：`a·b = b·a` 对所有 a,b 成立。

意义：如果在运算上有上述性质，很多代数/算法上的推导与简化成立（例如可重排求和）。浮点运算一般不满足结合律，因而不能当作阿贝尔群来处理（即不能随意重排求和以保证精度）。



（ 8） 根据课件第 41 页， 逐个说明这些等式成立或者不成立的原因， 以及不成立时， 是什
么运算结果。

P41

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250917135722354.png" alt="image-20250917135722354" style="zoom:50%;" />

Answer:

（一般性结论）：

- 加法的交换性在浮点下通常成立（`a + b == b + a` 通常 true，除了 NaN/Inf 情形）。
- 结合律（`(a + b) + c == a + (b + c)`）通常不成立，因为舍入引起差异。
- 乘法的结合性同上也可能不成立。
- 对于恒等/分配律（`a*(b + c) == a*b + a*c`）也不总成立。

（具体每条若需分项举例可继续展开，我在此提供关键结论与示例说明）





（ 9） 用十进制近似形式说明， 单精度浮点数（ 32 位） 和双精度浮点数（ 64 位） 各自能表
示的数值范围和大约的十进制有效数字位数是多少？

- **单精度 (32-bit)**：

  - 指数位 8 位 → 指数范围大约 `-126 ... +127`（规格化），动态范围约 `~10^{±38}`。
  - 有效数字（精度）约 **7–8 十进制有效数字**（23 位二进制尾数 → log10(2^24) ≈ 7.22）。

- **双精度 (64-bit)**：

  - 指数位 11 位 → 指数范围大约 `-1022 ... +1023`，动态范围约 `~10^{±308}`。
  - 有效数字约 **15–17 十进制有效数字**（52 位二进制尾数 → log10(2^53) ≈ 15.95）。

  



## 作业题

第 3 讲的作业题， 在教材第 2 章 信息的表示和处理， 页码和题号如下：


### 2.86

P93 2.86 与Intel兼容的处理器也支持“扩展精度”浮点形式，这种格式具有80位字长，被分成1个符号位、k=15个阶码位、1个单独的整数位和n=63个小数位。整数位是IEEE浮点表示中隐含位的显式副本。也就是说，对于规格化的值它等于1，对于非规格化的值它等于0。填写下表，给出用这种格式表示的一些“有趣的”数字的近似值。

| 描述               | 扩展精度 |        |
| ------------------ | -------- | ------ |
|                    | 值       | 十进制 |
| 最小的正非规格化数 |          |        |
| 最小的正规格化数   |          |        |
| 最大的规格化数     |          |        |

将数据类型声明为long double，就可以把这种格式用于为与Intel兼容的机器编译C程序。但是，它会强制编译器以传统的8087浮点指令为基础生成代码。由此产生的程序很可能会比数据类型为float或double的情况慢上许多。



Answer:

格式：80 位 = `1` 符号位, `k=15` 阶码位, `1` 显式整数位（整个位），`n=63` 小数位。整数位对规格化数为 1。题目要求填写最小正非规格化数、最小正规规格化数、最大规格化数的近似十进制值。

**方法**：

- 最小正非规格化数（denorm）对应 `exp = 0, frac = 1` → `E = 1 - bias`（bias = `2^(15-1) - 1 = 16383`），`M = frac/2^{63}`（因为显式整数位为 0 for denorm in extended format? Extended format has an explicit integer bit; for denorms integer bit is 0）。计算 `V = 2^{1-bias} * (frac / 2^{63})`。
- 最小正规化数对应 `exp = 1`，`M = 1.0` → `V = 1.0 × 2^{1 - bias}`。
- 最大正规化数对应 `exp = 2^15 - 2`（即 `exp = 32766`），`frac` 全 1 → `M` 接近 2。 结果近似为 `~ (2 - 2^{-63}) × 2^{(2^14 -1)}` 非常大（可用 log10 估算）。

（这些都可以按公式计算；若你需要我把数值列出到十进制科学计数形式，我可以算出并给出精确值 — 但量值非常大/非常小，通常用指数形式表示。）





**Intel 80-bit (extended)（k=15, n=63，bias=16383）**

| 描述                                   | 表达式（位域形式）   | 十进制（高精度近似）                                 |
| -------------------------------------- | -------------------- | ---------------------------------------------------- |
| 最小的正**非规格化**数 (min subnormal) | 2 1−16383−63=2−16445 | **3.6451995318824746025284059336194198163991E-4951** |
| 最小的**正规化**数 (min normal)        | 2 1−16383=2−16382    | **3.3621031431120935062626778173217526025981E-4932** |
| 最大的规格化数 (max normal)            | (2−2−63)×216383      | **1.1897314953572317650212638530309702051691E+4932** |

> 注：上面十进制为 `Decimal` 的高精度科学记数法（我用 80 位精度计算并保留了足够的有效位）。
> 逻辑说明：denorm 最小为 21−bias−n，最小正规化为 21−bias，最大正规化如上公式。

```python
from decimal import Decimal, getcontext
getcontext().prec = 80
k = 15
n = 63
bias = 2**(k-1) - 1
min_pos_denorm = Decimal(2) ** (1 - bias - n)
min_pos_normal = Decimal(2) ** (1 - bias)
E_max = (2**k - 2) - bias
max_normal = (Decimal(2) - (Decimal(1) / (Decimal(2) ** n))) * (Decimal(2) ** E_max)

print("2.86 80-bit extended precision (high-precision scientific notation)")
print("最小的正非规格化数 = 2^(1 - 16383 - 63) = 2^(-16445) ≈", f"{min_pos_denorm:.40E}")
print("最小的正规格化数 = 2^(1 - 16383) = 2^(-16382) ≈", f"{min_pos_normal:.40E}")
print("最大的规格化数 ≈ (2 - 2^(-63)) * 2^16383 ≈", f"{max_normal:.40E}")

"""
2.86 80-bit extended precision (high-precision scientific notation)
最小的正非规格化数 = 2^(1 - 16383 - 63) = 2^(-16445) ≈ 3.6451995318824746025284059336194198163991E-4951
最小的正规格化数 = 2^(1 - 16383) = 2^(-16382) ≈ 3.3621031431120935062626778173217526025981E-4932
最大的规格化数 ≈ (2 - 2^(-63)) * 2^16383 ≈ 1.1897314953572317650212638530309702051691E+4932
"""
```



### 2.87

P94 2.87 2008版IEEE浮点标准，即IEEE 754-2008，包含了一种16位的“半精度”浮点格式。它最初是由计算机图形公司设计的，其存储的数据所需的动态范围要高于16位整数可获得的范围。这种格式具有1个符号位、5个阶码位 (k=5) 和10个小数位 (n=10) 。阶码偏置量是 $2^(5-1)-1=15$。

对于每个给定的数，填写下表，其中，每一列具有如下指示说明：

- Hex：描述编码形式的4个十六进制数字。
- M：尾数的值。这应该是一个形如x或x/y的数，其中x是一个整数，而y是2的整数幂。例如：0、67/64和1/256。
- E：阶码的整数值。
- V：所表示的数字值。使用x或者x×2^z表示，其中x和z都是整数。
- D：(可能近似的)数值，用printf的格式规范%f打印。

举一个例子，为了表示数7/8，我们有s=0，M=7/4和E=-1。因此这个数的阶码字段为01110_2（十进制值15-1=14），尾数字段为11000000000_2，得到一个十六进制的表示3B00。其数值为0.875。

标记为“—”的条目不用填写。

| 描述                   | Hex  | M    | E    | V    | D     |
| ---------------------- | ---- | ---- | ---- | ---- | ----- |
| -0                     |      |      |      | -0   | -0.0  |
| 最小的>2的值           |      |      |      |      |       |
| 512                    |      |      |      | 512  | 512.0 |
| 最大的非规格化数       |      |      |      |      |       |
| -∞                     |      | —    | —    | -∞   | -∞    |
| 十六进制表示为3BB0的数 | 3BB0 |      |      |      |       |



Answer:

格式：16 位 = `s`(1) `exp`(5) `frac`(10)，bias=15。

我为表格中的若干条目给出具体结果与说明（供你直接填表核对）：

- **-0**：
  - Hex：`0x8000`（s=1，exp=0，frac=0）
  - V = -0.0 （打印 `-0.0`）
- **512**：
  - 表示为 `512 = 2^9`，规格化形式 `1.0 × 2^9`
  - `E_field = E + bias = 9 + 15 = 24 = 11000₂`
  - 二进制位：`s=0` `exp=11000` `frac=0000000000` → 16 位为 `0 11000 0000000000` = 二进制 `0110 0000 0000 0000` = `0x6000`。
  - Hex：`0x6000`，V=512.0，D 打印 `512.0`。
- **-∞**：
  - Hex：`0xFC00`（exp 全 1 = 31 (0b11111)，frac = 0，s=1 → `1 11111 0000000000`）
  - V = `-Inf`。
- **十六进制 3BB0 的数**（题里列出，要求给出其他栏）：
  - 我计算（解析 `0x3BB0`）：
    - `s = 0`
    - `exp = 0x3B >>?`（实际拆：0x3BB0 => 二进制 `0011 1011 1011 0000`）
    - 结果：`exp = 14`，`frac = 944`，`E = 14 - bias = -1`，`M = 1 + 944/1024 = 1 + 0.922 = 1.922`
    - `V = 1.922 × 2^{-1} = 0.9609375`。
  - 所以表格中 `3BB0` 对应 `V = 0.9609375`（D 字段）。

（其余表格条目按同样方法计算：解析 hex → 拆字段 → 计算 M/E → 得到 V；若需要我可以把表格全部填完并返回具体 hex/M/E/V/D 列表）





按题目表格的列（Hex, M, E, V, D）把每行都算出（D 列用 printf "%f" 风格显示到 6 位小数；同时给出精确有理式或幂-of-2 表示）。

| 描述                                      | Hex    | M （尾数）                           | E     | V（以 x×2z或 分数 表示）                    | D（printf %f 风格）                  |
| ----------------------------------------- | ------ | ------------------------------------ | ----- | ------------------------------------------- | ------------------------------------ |
| -0                                        | `8000` | —（无）                              | —     | `-0`                                        | **-0.0**                             |
| 最小的 > 2 的值（nextafter(2))            | `4001` | `1025/1024`(=1.0009765625)           | `1`   | `1025 × 2^{-9}` （等同于 `1025/512`）       | **2.001953**                         |
| 512                                       | `6000` | `1024/1024` = `1`                    | `9`   | `512 × 2^{0}`（即 `512`）                   | **512.0**                            |
| 最大的**非规格化数**（largest subnormal） | `03FF` | `1023/1024`                          | `-14` | `1023 × 2^{-24}` （等同于 `1023/16777216`） | **0.0000609756** (≈ `6.0975551e-05`) |
| -∞                                        | `FC00` | —                                    | —     | `-∞`                                        | **-Inf**                             |
| 十六进制表示为 `3BB0` 的数                | `3BB0` | `1968/1024` = **`123/64`**= 1.921875 | `-1`  | `123 × 2^{-7}` （等同于 `123/128`）         | **0.9609375**                        |

说明与核对要点：

- `-0` 的编码是 `0x8000`（sign=1, exp=0, frac=0）。按题目要求 M/E 可留空；数值是 -0.0（注意符号信息存在）。
- “最小的 > 2 的值”就是 `2` 的下一个可表示半精度数：`0x4001`（把 `0x4000` 加 1）。等价形式：1025512=1025×2−9，十进制约 `2.001953125`（按 `%f` 我写成 `2.001953`）。
- 最大的非规格化数：exp_field=0, frac=all-ones（1023）→ M=1023/1024,E=1−bias=−14。因此 V=1023×2−24=102316777216 ≈ `0.000060975551...` （我在表中四舍五入到 6-10 位以符合 `%f` 风格）。
- `3BB0` 的精确拆解：exp_field=14 → E=14−15=−1，frac 对应 1968/1024=123/64，所以 V=(123/64)×2−1=123/128=0.9609375。





### 2.89

P95 2.89 我们在一个 `int` 类型为 32 位补码表示的机器上运行程序。`float` 类型的值使用 32 位 IEEE 格式，而 `double` 类型的值使用 64 位 IEEE 格式。 

我们产生随机整数 `x`、`y` 和 `z`，并且把它们转换成 `double` 类型的值： 

```c
/* Create some arbitrary values */ 
int x = random(); 
int y = random(); 
int z = random(); 
/* Convert to double */ 
double dx = (double) x; 
double dy = (double) y; 
double dz = (double) z;
```



Answer:

**（关于 int->double 转换与随机值） — 说明与关键结论**

题目较长（教材习题），涉及把随机 `int x,y,z` 转成 `double`：`double dx = (double)x;` 等。通常相关问题会讨论浮点表示范围、是否能精确表示所有 32-bit int 在 double 中（可以，因为 double 精度 53 位，32-bit int 完全可精确表示），以及在 float（32-bit）中是否总能精确表示（否，float 只有 24 位精度，不能表示所有 32-bit int 精度）。

关键结论：

- 将 32-bit `int` 转 `double`（64-bit IEEE）**是精确的**，因为 double 的精度（53-bit）大于 32-bit 的整数位数。
- 将 32-bit `int` 转 `float`（32-bit）**不一定精确**，当 `|x| > 2^{24}` 时，float 无法表示所有整数；会丢失低位。

（如果你把题目后半部分贴出来或明确问哪一小问，我可以给出详细分支与示例数值）
